## Unit testing with Jest
Now that we have a working app it's time to test each piece of it (components, services...) to ensure that everything works as we expect and be able to do changes not having to be afraid of breaking something by mistake.

### Testing our first component: CountriesComponent
As we used Angular CLI to create our component we have an initial set up to start covering our component with more tests.

`CountriesComponent` shows a list of elements that you can click to send data somewhere else, then we need two different tests:
1. Test that we render a list of elements.
2. Test that when we click on an element we send the expected value associated with that element.

So let's start testing!

Go to ``countries.component.spec.ts``. You will find a file with a single test:

```typescript
it('should create', () => {
  expect(component).toBeTruthy();
});
```

If you check our `CountriesComponent` you will see that we are importing two services (`CountriesService` and `CityService`). We need to add both services to the TestBed as providers.

```typescript
TestBed.configureTestingModule({
  declarations: [ CountriesComponent ],
  providers: [ CountriesService, CityService ]
})
```

This will inject our services in the context but remember that our goal is to unit test `CountriesComponent`, not its dependencies, so we need to mock both services to get rid of side effects and be able to spy on them and check if they are being used or to change what they are returning.

Jest makes mocking a super easy thing, we just need to use `jest.mock(PATH_TO_YOUR_SERVICE)`.

```typescript
jest.mock('./countries.service');
jest.mock('../city.service');
```

Now we are going to get our services from the testing context and store them in a variable so we can use them.

```typescript
countriesService = TestBed.get(CountriesService);
cityService = TestBed.get(CityService);
```

We don't want `CountriesServices` to perform an HTTP call to retrieve the list of countries so we have to mock `getCountries()` to return what we want.

```typescript
jest.spyOn(countriesService, 'getCountries').mockReturnValue(of([
  { country: 'Spain', city: 'Madrid' },
  { country: 'France', city: 'Paris'}
]));
```

To check that we emit a city whenever we click on an element we need to create a spy that will tell us if `emitCity` has been called or not.

```typescript
jest.spyOn(cityService, 'emitCity');
```

Finally we can add our test cases.

We want to test what it's being rendered. To do that we can take advantage of the jest snapshots.

```typescript
it('should render component', () => {
  expect(fixture).toMatchSnapshot();
});
```

This will create a folder named `__snapshots__` at the same level of our test with a file `countries.component.speec.ts.snap`. 
```
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`CountriesComponent should render component 1`] = `
<nrwl-angular-jest-cypress-countries
  cityService={[Function CityService]}
  countries$={[Function Observable]}
  countriesService={[Function CountriesService]}
>
  <div>
    <ul>
      
      <li>
        Spain
      </li>
      <li>
        France
      </li>
    </ul>
  </div>
</nrwl-angular-jest-cypress-countries>
`;

```

The content of this file is the HTML generated by our component.

Next time we run the test jest will compare the new generated HTML against the one in this file, if both matches the test will pass, if not, the test will fail.

What if my test fail because I introduced a change in the HTML? Well, then you need to check that the difference between the snapshot and the result is the expected one, if so, you just need to run the test with a flag to tell jest to update that spanshot with the new HTML.

```
ng test -u
```